# Script Execution Model & Luau Runtime

**Date:** 2026-02-19
**Status:** Approved

## Problem

The transpiler has three bugs that prevent scripts from running in Roblox:

1. **File extensions** — All output files use `.lua`, so Rojo creates ModuleScripts for everything. Server scripts need `.server.lua` and client scripts need `.client.lua`.
2. **ScriptType determination** — `TransformPipeline` always falls through to `ModuleScript` because it only looks up a class named `"Main"`, but actual classes use names like `ClientMain`, `ServerMain`.
3. **Entry point never called** — `GameEntry()` is emitted as a method but nothing calls it. For Script/LocalScript types, the transpiler should append `ClassName:GameEntry()` at the bottom.

Additionally, `out/runtime/` is mapped in the Rojo config but nothing populates it. The transpiler needs runtime Luau utilities for OOP, events, and safe imports.

## Part 1: Fix Script Execution

### 1a. File Extensions — `TransformPipeline.DeriveOutputPath()`

| Context | Current output | Fixed output |
|---------|---------------|--------------|
| `src/server/Foo.cs` | `server/Foo.lua` | `server/Foo.server.lua` |
| `src/client/Bar.cs` | `client/Bar.lua` | `client/Bar.client.lua` |
| `src/shared/Baz.cs` | `shared/Baz.lua` | `shared/Baz.lua` (unchanged) |

### 1b. ScriptType Determination — `TransformPipeline` Pass 3

Stop hardcoding `"Main"` class lookup. Instead, for each file:
- Look up ScriptType from the SymbolTable using the actual class names in the file
- Use the first non-ModuleScript type found (a file with a Script-type class is a Script)
- Fall back to path-based detection from `SymbolCollector.DetermineScriptType()`

### 1c. Entry Call — `ModuleEmitter`

For Script and LocalScript types, after emitting all classes, append:
```lua
ClassName:GameEntry()
```

For ModuleScript types, emit `return ClassName` as before. No entry call.

### Expected Output

**Server script (`out/server/ServerMain.server.lua`):**
```lua
-- Generated by LUSharp
local ServerMain = {}

function ServerMain:GameEntry()
    print("Server starting...")
end

ServerMain:GameEntry()
```

**Module (`out/shared/SharedModule.lua`):**
```lua
-- Generated by LUSharp
local SharedModule = {}
SharedModule.MapSize = 200
return SharedModule
```

## Part 2: Luau Runtime (`out/runtime/`)

Three static Luau modules bundled with LUSharp, copied to `out/runtime/` during build. The transpiler emits `require()` calls to them as needed.

### 2a. Class System — `Class.lua`

Provides OOP support via metatables: constructors, inheritance, instance fields, `self`.

```lua
local Class = {}

function Class.new(name, base)
    local cls = {}
    cls.__index = cls
    cls.__name = name
    if base then
        setmetatable(cls, { __index = base })
    end

    function cls.new(...)
        local self = setmetatable({}, cls)
        if cls._constructor then
            cls._constructor(self, ...)
        end
        return self
    end

    return cls
end

return Class
```

Transpiler emits `Class.new("Name")` instead of plain `{}` tables. Inheritance uses `Class.new("Child", Parent)`.

### 2b. Signal / Event System — `Signal.lua`

Lightweight signal for C# event patterns. Avoids BindableEvent overhead.

```lua
local Signal = {}
Signal.__index = Signal

function Signal.new()
    return setmetatable({ _handlers = {} }, Signal)
end

function Signal:Connect(fn)
    table.insert(self._handlers, fn)
    return {
        Disconnect = function()
            local idx = table.find(self._handlers, fn)
            if idx then table.remove(self._handlers, idx) end
        end
    }
end

function Signal:Fire(...)
    for _, fn in self._handlers do
        fn(...)
    end
end

function Signal:Wait()
    local co = coroutine.running()
    local conn
    conn = self:Connect(function(...)
        conn.Disconnect()
        coroutine.resume(co, ...)
    end)
    return coroutine.yield()
end

return Signal
```

C# mapping:

| C# | Luau |
|---|---|
| `event Action<Player> OnJoined;` | `MyClass.OnJoined = Signal.new()` |
| `OnJoined += handler` | `MyClass.OnJoined:Connect(handler)` |
| `OnJoined -= handler` | `connection:Disconnect()` |
| `OnJoined?.Invoke(player)` | `MyClass.OnJoined:Fire(player)` |

### 2c. Import Helper — `Import.lua`

Thin wrapper around `require()` for error messages.

```lua
local Import = {}

function Import.require(path)
    local ok, result = pcall(require, path)
    if not ok then
        warn("[LUSharp] Failed to require: " .. tostring(path) .. "\n" .. tostring(result))
        error(result)
    end
    return result
end

return Import
```

### Delivery

Runtime files are embedded resources in the LUSharp CLI. During `lusharp build`, they are copied to `out/runtime/`. The `lusharp fix` command verifies they exist.

## Files to Modify

| File | Change |
|------|--------|
| `LUSharpTranspiler/Transform/TransformPipeline.cs` | Fix `DeriveOutputPath()` extensions, fix ScriptType lookup in Pass 3 |
| `LUSharpTranspiler/Backend/ModuleEmitter.cs` | Append `GameEntry()` call for Script/LocalScript |
| New: `LUSharp/Runtime/Class.lua` | Embedded resource — class system |
| New: `LUSharp/Runtime/Signal.lua` | Embedded resource — event system |
| New: `LUSharp/Runtime/Import.lua` | Embedded resource — import helper |
| `LUSharpTranspiler/Build/BuildCommand.cs` | Copy runtime files to `out/runtime/` during build |
| `LUSharp/ProjectFixer.cs` | Add check for runtime files in `out/runtime/` |
