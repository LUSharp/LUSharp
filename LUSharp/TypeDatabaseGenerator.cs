using System.Reflection;
using System.Text;
using LUSharpAPI.Runtime.Internal;

namespace LUSharp;

internal static class TypeDatabaseGenerator
{
    public static int Run()
    {
        try
        {
            Console.Write(GenerateLua());
            return 0;
        }
        catch (Exception ex)
        {
            Logger.Log(Logger.LogSeverity.Error, $"Failed to generate type database: {ex.Message}");
            return 1;
        }
    }

    internal static string GenerateLua()
    {
        var assembly = typeof(RobloxScript).Assembly;
        var types = assembly
            .GetTypes()
            .Where(t => t.IsPublic && t.Namespace is not null && t.Namespace.StartsWith("LUSharpAPI"))
            .OrderBy(t => t.FullName, StringComparer.Ordinal)
            .ToList();

        var sb = new StringBuilder();
        sb.AppendLine("-- Auto-generated by `lusharp generate-types`");
        sb.AppendLine("-- Source: LUSharpAPI reflection metadata");
        sb.AppendLine();
        sb.AppendLine("local TypeDatabase = {");
        sb.AppendLine("    types = {");

        foreach (var type in types)
        {
            var fullName = type.FullName ?? type.Name;
            sb.AppendLine($"        [{LuaString(fullName)}] = {{");
            sb.AppendLine($"            name = {LuaString(type.Name)},");
            sb.AppendLine($"            fullName = {LuaString(fullName)},");
            sb.AppendLine($"            namespace = {LuaString(type.Namespace ?? string.Empty)},");
            sb.AppendLine($"            kind = {LuaString(GetTypeKind(type))},");
            sb.AppendLine($"            baseType = {LuaString(type.BaseType is null ? string.Empty : ToTypeName(type.BaseType))},");
            sb.AppendLine($"            enumValues = {EmitEnumValues(type)},");
            sb.AppendLine("            members = {");

            foreach (var memberLine in EmitMembers(type))
                sb.AppendLine($"                {memberLine}");

            sb.AppendLine("            },");
            sb.AppendLine("        },");
        }

        sb.AppendLine("    },");
        sb.AppendLine("    aliases = {");

        foreach (var alias in EmitAliases(types))
            sb.AppendLine($"        {alias}");

        sb.AppendLine("    },");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("return TypeDatabase");

        return sb.ToString();
    }

    private static IEnumerable<string> EmitMembers(Type type)
    {
        const BindingFlags flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly;

        foreach (var ctor in type.GetConstructors(flags).OrderBy(c => c.ToString(), StringComparer.Ordinal))
        {
            yield return "{";
            yield return $"    kind = {LuaString("constructor")},";
            yield return $"    name = {LuaString(type.Name)},";
            yield return "    static = false,";
            yield return $"    parameters = {EmitParameters(ctor.GetParameters())},";
            yield return "},";
        }

        foreach (var field in type.GetFields(flags).OrderBy(f => f.Name, StringComparer.Ordinal))
        {
            yield return "{";
            yield return $"    kind = {LuaString("field")},";
            yield return $"    name = {LuaString(field.Name)},";
            yield return $"    static = {LuaBool(field.IsStatic)},";
            yield return $"    type = {LuaString(ToTypeName(field.FieldType))},";
            yield return "},";
        }

        foreach (var prop in type.GetProperties(flags).OrderBy(p => p.Name, StringComparer.Ordinal))
        {
            var accessor = prop.GetMethod ?? prop.SetMethod;
            var isStatic = accessor?.IsStatic ?? false;
            yield return "{";
            yield return $"    kind = {LuaString("property")},";
            yield return $"    name = {LuaString(prop.Name)},";
            yield return $"    static = {LuaBool(isStatic)},";
            yield return $"    type = {LuaString(ToTypeName(prop.PropertyType))},";
            yield return $"    canRead = {LuaBool(prop.CanRead)},";
            yield return $"    canWrite = {LuaBool(prop.CanWrite)},";
            yield return "},";
        }

        foreach (var evt in type.GetEvents(flags).OrderBy(e => e.Name, StringComparer.Ordinal))
        {
            var adder = evt.AddMethod;
            var isStatic = adder?.IsStatic ?? false;
            yield return "{";
            yield return $"    kind = {LuaString("event")},";
            yield return $"    name = {LuaString(evt.Name)},";
            yield return $"    static = {LuaBool(isStatic)},";
            yield return $"    type = {LuaString(ToTypeName(evt.EventHandlerType ?? typeof(object)))},";
            yield return "},";
        }

        foreach (var method in type.GetMethods(flags)
                     .Where(m => !m.IsSpecialName)
                     .OrderBy(m => m.Name, StringComparer.Ordinal)
                     .ThenBy(m => m.GetParameters().Length))
        {
            yield return "{";
            yield return $"    kind = {LuaString("method")},";
            yield return $"    name = {LuaString(method.Name)},";
            yield return $"    static = {LuaBool(method.IsStatic)},";
            yield return $"    returnType = {LuaString(ToTypeName(method.ReturnType))},";
            yield return $"    parameters = {EmitParameters(method.GetParameters())},";
            yield return "},";
        }
    }

    private static IEnumerable<string> EmitAliases(IEnumerable<Type> types)
    {
        foreach (var group in types.GroupBy(t => t.Name).OrderBy(g => g.Key, StringComparer.Ordinal))
        {
            if (group.Count() == 1)
            {
                var t = group.First();
                yield return $"[{LuaString(t.Name)}] = {LuaString(t.FullName ?? t.Name)},";
            }
            else
            {
                foreach (var t in group.OrderBy(t => t.FullName, StringComparer.Ordinal))
                {
                    var key = $"{t.Namespace}.{t.Name}";
                    yield return $"[{LuaString(key)}] = {LuaString(t.FullName ?? t.Name)},";
                }
            }
        }
    }

    private static string EmitEnumValues(Type type)
    {
        if (!type.IsEnum)
            return "{}";

        var names = Enum.GetNames(type).OrderBy(n => n, StringComparer.Ordinal).ToList();
        var values = names.Select(n => $"[{LuaString(n)}] = {Convert.ToInt64(Enum.Parse(type, n))}");
        return "{ " + string.Join(", ", values) + " }";
    }

    private static string EmitParameters(IEnumerable<ParameterInfo> parameters)
    {
        var list = parameters.Select(p =>
            "{ " +
            $"name = {LuaString(p.Name ?? "arg")}, " +
            $"type = {LuaString(ToTypeName(p.ParameterType))}" +
            " }");

        return "{ " + string.Join(", ", list) + " }";
    }

    private static string GetTypeKind(Type type)
    {
        if (type.IsEnum) return "enum";
        if (type.IsInterface) return "interface";
        if (typeof(MulticastDelegate).IsAssignableFrom(type.BaseType)) return "delegate";
        if (type.IsValueType && !type.IsPrimitive) return "struct";
        return "class";
    }

    private static string ToTypeName(Type type)
    {
        if (type.IsGenericParameter)
            return type.Name;

        var nullableUnderlying = Nullable.GetUnderlyingType(type);
        if (nullableUnderlying is not null)
            return ToTypeName(nullableUnderlying) + "?";

        if (type.IsArray)
            return ToTypeName(type.GetElementType()!) + "[]";

        if (type.IsGenericType)
        {
            var name = type.Name.Split('`')[0];
            var args = type.GetGenericArguments().Select(ToTypeName);
            return $"{name}<{string.Join(", ", args)}>";
        }

        return type.Name;
    }

    private static string LuaString(string value)
    {
        var escaped = value
            .Replace("\\", "\\\\", StringComparison.Ordinal)
            .Replace("\"", "\\\"", StringComparison.Ordinal)
            .Replace("\r", "\\r", StringComparison.Ordinal)
            .Replace("\n", "\\n", StringComparison.Ordinal)
            .Replace("\t", "\\t", StringComparison.Ordinal);

        return $"\"{escaped}\"";
    }

    private static string LuaBool(bool value) => value ? "true" : "false";
}
