using System.Text;
using LUSharpApiGenerator.Models;

namespace LUSharpApiGenerator.Generation;

public class ClassGenerator
{
    private readonly TypeMapper _typeMapper;
    private readonly CSharpNaming _naming;
    private readonly InheritanceResolver _resolver;

    // Hand-written classes/services to skip
    private static readonly HashSet<string> SkipClasses = new()
    {
        "Instance", "PVInstance", "BasePart", "Part", "Model", "SpawnLocation",
        "WorldRoot", "Player", "Mouse", "Actor", "Team", "HumanoidDescription",
        "DataModel", "BaseScript", "LuaSourceContainer", "ModuleScript", "RObject",
        "Object"
    };

    private static readonly HashSet<string> SkipServices = new()
    {
        "Players", "Workspace"
    };

    // Map hand-written class names to their fully qualified C# type names
    private static readonly Dictionary<string, string> HandWrittenClassFQN = new()
    {
        ["RObject"] = "LUSharpAPI.Runtime.STL.Classes.RObject",
        ["DataModel"] = "LUSharpAPI.Runtime.STL.Classes.DataModel",
        ["Instance"] = "LUSharpAPI.Runtime.STL.Classes.Instance.Instance",
        ["Actor"] = "LUSharpAPI.Runtime.STL.Classes.Instance.Actor",
        ["Player"] = "LUSharpAPI.Runtime.STL.Classes.Instance.Player",
        ["Mouse"] = "LUSharpAPI.Runtime.STL.Classes.Instance.Mouse",
        ["Team"] = "LUSharpAPI.Runtime.STL.Classes.Instance.Team",
        ["HumanoidDescription"] = "LUSharpAPI.Runtime.STL.Classes.Instance.HumanoidDescription",
        ["PVInstance"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.PVInstance",
        ["BasePart"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.BasePart",
        ["Part"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.Part",
        ["Model"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.Model",
        ["SpawnLocation"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.SpawnLocation",
        ["WorldRoot"] = "LUSharpAPI.Runtime.STL.Classes.Instance.PVInstance.WorldRoot",
        ["BaseScript"] = "LUSharpAPI.Runtime.STL.Classes.Instance.LuaSourceContainer.BaseScript",
        ["LuaSourceContainer"] = "LUSharpAPI.Runtime.STL.Classes.Instance.LuaSourceContainer.LuaSourceContainer",
        ["ModuleScript"] = "LUSharpAPI.Runtime.STL.Classes.Instance.LuaSourceContainer.ModuleScript",
    };

    public ClassGenerator(TypeMapper typeMapper, CSharpNaming naming, InheritanceResolver resolver)
    {
        _typeMapper = typeMapper;
        _naming = naming;
        _resolver = resolver;
    }

    public (int ClassCount, int ServiceCount) Generate(List<ApiClass> classes, string apiProjectRoot)
    {
        string classDir = Path.Combine(apiProjectRoot, "Runtime", "STL", "Generated", "Classes");
        string serviceDir = Path.Combine(apiProjectRoot, "Runtime", "STL", "Generated", "Services");
        Directory.CreateDirectory(classDir);
        Directory.CreateDirectory(serviceDir);

        // Populate known class/enum names in TypeMapper
        foreach (var cls in classes)
            _typeMapper.AllClassNames.Add(cls.Name);

        int classCount = 0;
        int serviceCount = 0;

        foreach (var cls in classes)
        {
            if (SkipClasses.Contains(cls.Name))
                continue;

            bool isService = cls.IsService;
            if (isService && SkipServices.Contains(cls.Name))
                continue;

            string dir = isService ? serviceDir : classDir;
            string ns = isService
                ? "LUSharpAPI.Runtime.STL.Services"
                : "LUSharpAPI.Runtime.STL.Classes";

            string filePath = Path.Combine(dir, $"{cls.Name}.cs");
            File.WriteAllText(filePath, GenerateClass(cls, ns));

            if (isService) serviceCount++;
            else classCount++;
        }

        return (classCount, serviceCount);
    }

    private string GenerateClass(ApiClass cls, string ns)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by LUSharpApiGenerator — do not edit manually.");
        sb.AppendLine();

        // Using directives
        sb.AppendLine("using LUSharpAPI.Runtime.STL.Types;");
        sb.AppendLine("using LUSharpAPI.Runtime.STL.Enums;");
        sb.AppendLine("using LUSharpAPI.Runtime.STL.LuaToC;");
        // Generated classes/services reference each other
        if (ns != "LUSharpAPI.Runtime.STL.Classes")
            sb.AppendLine("using LUSharpAPI.Runtime.STL.Classes;");
        if (ns != "LUSharpAPI.Runtime.STL.Services")
            sb.AppendLine("using LUSharpAPI.Runtime.STL.Services;");
        sb.AppendLine();

        sb.AppendLine($"namespace {ns}");
        sb.AppendLine("{");

        // XML doc for NotCreatable
        if (cls.IsNotCreatable)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// This class is not creatable.");
            sb.AppendLine("    /// </summary>");
        }

        // Class declaration
        string? baseClass = ResolveBaseClass(cls);
        string baseClassRef = baseClass != null ? QualifyTypeName(baseClass) : "";
        string inheritance = baseClass != null ? $" : {baseClassRef}" : "";
        sb.AppendLine($"    public class {cls.Name}{inheritance}");
        sb.AppendLine("    {");

        bool hasMembers = false;

        // Properties
        foreach (var member in cls.Members)
        {
            if (member is ApiProperty prop)
            {
                if (hasMembers) sb.AppendLine();
                GenerateProperty(sb, prop, cls.Name);
                hasMembers = true;
            }
        }

        // Functions
        foreach (var member in cls.Members)
        {
            if (member is ApiFunction func)
            {
                if (hasMembers) sb.AppendLine();
                GenerateFunction(sb, func, cls.Name);
                hasMembers = true;
            }
        }

        // Events
        foreach (var member in cls.Members)
        {
            if (member is ApiEvent evt)
            {
                if (hasMembers) sb.AppendLine();
                GenerateEvent(sb, evt, cls.Name);
                hasMembers = true;
            }
        }

        // Callbacks
        foreach (var member in cls.Members)
        {
            if (member is ApiCallback cb)
            {
                if (hasMembers) sb.AppendLine();
                GenerateCallback(sb, cb, cls.Name);
                hasMembers = true;
            }
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private string? ResolveBaseClass(ApiClass cls)
    {
        return _resolver.GetBaseClass(cls.Name);
    }

    /// <summary>
    /// Qualify type references: hand-written classes get their full namespace.
    /// Also handles name collisions with System types.
    /// </summary>
    private string QualifyTypeName(string typeName)
    {
        // Strip nullable suffix for lookup, re-add after
        bool nullable = typeName.EndsWith('?');
        string baseName = nullable ? typeName[..^1] : typeName;
        string suffix = nullable ? "?" : "";

        // Hand-written classes → fully qualified
        if (HandWrittenClassFQN.TryGetValue(baseName, out var fqn))
            return $"global::{fqn}{suffix}";

        // Disambiguate types that conflict with System namespace
        if (baseName == "DateTime")
            return $"LUSharpAPI.Runtime.STL.Types.DateTime{suffix}";
        if (baseName == "Path")
            return $"LUSharpAPI.Runtime.STL.Classes.Path{suffix}";

        // Disambiguate enum Font from data type Font
        if (baseName == "Font")
            return $"LUSharpAPI.Runtime.STL.Enums.Font{suffix}";

        return typeName;
    }

    /// <summary>
    /// Map a type and qualify it for generated code context.
    /// </summary>
    private string MapAndQualify(ApiValueType vt)
    {
        string mapped = _typeMapper.MapType(vt);

        // For DataType-category Font, use Types.Font instead of Enums.Font
        if (vt.Category == "DataType" && vt.Name == "Font")
            return "LUSharpAPI.Runtime.STL.Types.Font";

        return QualifyTypeName(mapped);
    }

    private string MapAndQualifyReturn(ApiReturnType rt)
    {
        if (rt.IsTuple)
        {
            var types = rt.Types.Select(t => MapAndQualify(t)).ToList();
            return $"({string.Join(", ", types)})";
        }
        string mapped = _typeMapper.MapReturnType(rt.Single);
        return mapped == "void" ? "void" : QualifyTypeName(mapped);
    }

    private void GenerateProperty(StringBuilder sb, ApiProperty prop, string className)
    {
        string type = MapAndQualify(prop.ValueType);
        string name = _naming.EscapeIdentifier(prop.Name);

        // Avoid member name same as enclosing type
        if (name == className)
            name = name + "Value";

        bool readOnly = prop.IsReadOnly || prop.Security.Write != "None";

        if (readOnly)
            sb.AppendLine($"        public {type} {name} {{ get; }}");
        else
            sb.AppendLine($"        public {type} {name} {{ get; set; }}");
    }

    private void GenerateFunction(StringBuilder sb, ApiFunction func, string className)
    {
        string returnType = MapAndQualifyReturn(func.ReturnType);
        string name = _naming.EscapeIdentifier(func.Name);

        if (name == className)
            name = name + "Method";

        string parameters = GenerateParameters(func.Parameters);

        sb.AppendLine($"        public {returnType} {name}({parameters}) {{ throw new NotImplementedException(); }}");
    }

    private void GenerateEvent(StringBuilder sb, ApiEvent evt, string className)
    {
        string name = _naming.EscapeIdentifier(evt.Name);
        if (name == className)
            name = name + "Event";

        string signalType = GenerateSignalType(evt.Parameters);
        sb.AppendLine($"        public {signalType} {name} {{ get; set; }}");
    }

    private void GenerateCallback(StringBuilder sb, ApiCallback cb, string className)
    {
        string name = _naming.EscapeIdentifier(cb.Name);
        if (name == className)
            name = name + "Callback";

        string returnType = MapAndQualifyReturn(cb.ReturnType);
        var paramTypes = cb.Parameters.Select(p => MapAndQualify(p.Type)).ToList();

        string delegateType;
        if (returnType == "void")
        {
            delegateType = paramTypes.Count == 0
                ? "Action"
                : $"Action<{string.Join(", ", paramTypes)}>";
        }
        else
        {
            var allTypes = paramTypes.Concat(new[] { returnType });
            delegateType = $"Func<{string.Join(", ", allTypes)}>";
        }

        sb.AppendLine($"        public {delegateType}? {name} {{ get; set; }}");
    }

    private string GenerateSignalType(List<ApiParameter> parameters)
    {
        if (parameters.Count == 0)
            return "RBXScriptSignal";

        var typeArgs = parameters.Select(p => MapAndQualify(p.Type)).ToList();

        // Cap at 6 type parameters (our max generic variant)
        if (typeArgs.Count > 6)
            typeArgs = typeArgs.Take(6).ToList();

        return $"RBXScriptSignal<{string.Join(", ", typeArgs)}>";
    }

    private string GenerateParameters(List<ApiParameter> parameters)
    {
        // Split into required and optional, ensuring required come first
        var required = new List<string>();
        var optional = new List<string>();

        foreach (var p in parameters)
        {
            string type = MapAndQualify(p.Type);
            string name = _naming.EscapeParameterName(p.Name);

            if (p.Default != null)
            {
                string defaultVal = MapDefaultValue(p.Default, type);
                optional.Add($"{type} {name} = {defaultVal}");
            }
            else
            {
                required.Add($"{type} {name}");
            }
        }

        // Required params first, then optional
        var all = required.Concat(optional);
        return string.Join(", ", all);
    }

    private string MapDefaultValue(string defaultValue, string csharpType)
    {
        if (defaultValue == "" || defaultValue == "nil")
            return GetTypeDefault(csharpType);

        if (defaultValue == "true") return "true";
        if (defaultValue == "false") return "false";

        // Numeric
        if (double.TryParse(defaultValue, System.Globalization.NumberStyles.Any,
            System.Globalization.CultureInfo.InvariantCulture, out _))
        {
            if (csharpType == "float") return defaultValue + "f";
            return defaultValue;
        }

        // String
        if (csharpType == "string")
            return $"\"{EscapeStringLiteral(defaultValue)}\"";

        // Enum default: e.g. "Enum.Material.Plastic"
        if (defaultValue.StartsWith("Enum."))
        {
            var parts = defaultValue.Split('.');
            if (parts.Length == 3)
                return $"{parts[1]}.{parts[2]}";
        }

        return GetTypeDefault(csharpType);
    }

    private static string GetTypeDefault(string csharpType)
    {
        // Strip nullable
        string baseType = csharpType.TrimEnd('?');
        bool isNullable = csharpType.EndsWith('?');

        if (isNullable) return "null";

        return baseType switch
        {
            "string" => "\"\"",
            "bool" => "false",
            "int" => "0",
            "long" => "0",
            "float" => "0f",
            "double" => "0",
            "void" => "default",
            _ => "default!"
        };
    }

    private static string EscapeStringLiteral(string s)
    {
        return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
