using System.Text;
using LUSharpApiGenerator.Models;

namespace LUSharpApiGenerator.Generation;

public class DataTypeGenerator
{
    private readonly TypeMapper _typeMapper;
    private readonly CSharpNaming _naming;

    // Hand-written types to skip
    private static readonly HashSet<string> SkipTypes = new()
    {
        "BrickColor", "CFrame", "Color3", "Content", "Enum", "EnumItem", "Enums",
        "Faces", "OverlapParams", "PhysicalProperties", "RBXScriptConnection",
        "Ray", "RaycastParams", "RBXScriptSignal", "RaycastResult", "Vector3"
    };

    // Types that shouldn't be generated as classes (they map to primitives/special)
    private static readonly HashSet<string> NonClassTypes = new()
    {
        "string", "bool", "int", "int64", "float", "double", "void",
        "Content", "ProtectedString", "BinaryString", "buffer",
        "Variant", "Objects", "Function", "CoordinateFrame",
        "OptionalCoordinateFrame", "Tuple", "Array", "Dictionary",
        "QDir", "QFont", "QColor",
    };

    public DataTypeGenerator(TypeMapper typeMapper, CSharpNaming naming)
    {
        _typeMapper = typeMapper;
        _naming = naming;
    }

    public int Generate(List<ApiClass> classes, string apiProjectRoot)
    {
        string outDir = Path.Combine(apiProjectRoot, "Runtime", "STL", "Generated", "DataTypes");
        Directory.CreateDirectory(outDir);

        // Collect all DataType references from the API
        var dataTypes = new HashSet<string>();
        foreach (var cls in classes)
        {
            foreach (var member in cls.Members)
            {
                CollectDataTypes(member, dataTypes);
            }
        }

        // Also include types tracked by TypeMapper
        foreach (var dt in _typeMapper.ReferencedDataTypes)
            dataTypes.Add(dt);

        int count = 0;
        foreach (var typeName in dataTypes.OrderBy(t => t))
        {
            if (SkipTypes.Contains(typeName))
                continue;
            if (NonClassTypes.Contains(typeName))
                continue;
            // Skip names with invalid filename characters or that are mapped to other types
            if (typeName.Contains('?') || typeName.Contains('<') || typeName.Contains('>'))
                continue;
            // Skip names that are already mapped to special types
            string mapped = _typeMapper.MapType(new Models.ApiValueType { Name = typeName, Category = "DataType" });
            if (mapped != typeName)
                continue;

            string filePath = Path.Combine(outDir, $"{typeName}.cs");
            File.WriteAllText(filePath, GenerateDataType(typeName));
            count++;
        }

        return count;
    }

    private void CollectDataTypes(ApiMember member, HashSet<string> dataTypes)
    {
        switch (member)
        {
            case ApiProperty prop:
                if (prop.ValueType.Category == "DataType")
                    dataTypes.Add(prop.ValueType.Name);
                break;
            case ApiFunction func:
                foreach (var rt in func.ReturnType.Types)
                    if (rt.Category == "DataType")
                        dataTypes.Add(rt.Name);
                foreach (var p in func.Parameters)
                    if (p.Type.Category == "DataType")
                        dataTypes.Add(p.Type.Name);
                break;
            case ApiEvent evt:
                foreach (var p in evt.Parameters)
                    if (p.Type.Category == "DataType")
                        dataTypes.Add(p.Type.Name);
                break;
            case ApiCallback cb:
                foreach (var rt in cb.ReturnType.Types)
                    if (rt.Category == "DataType")
                        dataTypes.Add(rt.Name);
                foreach (var p in cb.Parameters)
                    if (p.Type.Category == "DataType")
                        dataTypes.Add(p.Type.Name);
                break;
        }
    }

    private string GenerateDataType(string name)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by LUSharpApiGenerator â€” do not edit manually.");
        sb.AppendLine();
        sb.AppendLine("namespace LUSharpAPI.Runtime.STL.Types");
        sb.AppendLine("{");
        sb.AppendLine($"    public class {_naming.EscapeIdentifier(name)}");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }
}
